# 객체, 설계

## 소프트웨어 모듈이 가져야 하는 세가지 기능
- 실행 중에 제대로 동작하는 것
- 목적은 변경을 위해 존재하는 것
- 코드를 읽는 사람과 의사소통하는 것

요약: 모듈은 제대로 실행돼야하고, 변경이 용이해야하며, 이해하기 쉬워햐한다.

### 의존성에 대해..
- 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포됨
- 의존성을 없애는 것이 답이 아님
- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것
- 목표는 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것
- 의존성이 과한 경우 **결합도(Coupling)**가 높다고함
- 객체 사이에 결합도가 높으면 높을수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워짐.

### 캡슐화
- 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것
- 목적은 변경하기 쉬운 객체를 만드는 것
- 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게됨

### 캡슐화와 응집도
- 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메세지를 통해서만 상호작용하도록 만드는 것
- **응집도(Cohesion)** 가 높은 객체: 밀접하게 연관된 작업만들 수행하고 연관성이 없는 작업은 다른 객체에게 위임하는 객체를 가리킴
- 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야함
- 객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야함
- 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길임

### 절차지향과 객체지향
- 1장 수정되기 전 코드에서 Theater의 `enter` 함수는 **프로세스(Process)** 이며 Audition, TicketSeller, Bag, TicketOffice는 **데이터(Data)** 다.
- 이처럼 프로세스와 데이터를 별도의 모듈에 위치하는 방식을 **절차적 프로그래밍(Procedural Programming)** 이라고 부른다.
- 절차적 프로그래밍은 프로세스가 거의 모든 의존을 가지고 있기 때문에 변경이 어렵다.
- 변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다.
- 반대로, 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 **객체지향 프로그래밍 (Object-Oriented Programming)** 이라고 부른다.
- 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함을써 객체 사이의 결합도를 낮추는 것이다.

### 책임의 이동
- 위 2개의 방식의 근본적인 차이를 만드는 것은 **책임의 이동(Shift of responsibility)** 다.
- 객체지향 설계에서는 독재가가 존재하지 않고 각 객체에 책임이 적절하게 분배된다. 따라서 각 객체는 자신을 스스로 책임진다.
- 객체지향 설계는 스스로 책임을 수행하는 자율적인 객체들의 공동체를 구성함으로써 완성된다.
- 설계를 어렵게 만드는 것은 의존성이라는것을 기억하자.

### 의인화
- 비록 현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바쒼다.
- 능동적이고 자율적인 존재로 스프트웨어 객체를 설계하는 원칙을 **의인화(anthropomorphism)** 이라고 부른다.

# 객체지향 프로그래밍

## 객체지향 프로그래밍

### 협력, 객체, 클래스
- 진정한 객체지향 페러다임으로서의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.
- 첫째, 어떵 클래스가 핋요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라
  - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것
  - 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야함
- 둘째, 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야함
  - 객체는 홀로 존재하는 것이 아닌 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존대

### 도메인의 구조를 따르는 프로그램 구조
- 소프트웨어는 사용자가 원하는 어떤 문제를 해결하기 위해 만들어진다. 이처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 **도메인** 이라고 부른다.
- 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다.

#### 자융적인 객체
- 객체는 **상태(state)** 와 **행동(behavior)** 을 함께 가지는 복합적은 존재다.
- 객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶으으로써 문제 영역의 아이디어를 적절하게 표현할 수 있다.
- 이처럼 데이터와 기능을 객체 내부로 함께 묶는 것을 **캡슐화** 라고 한다.
- 나아가 외부에서의 접근을 통제할 수 있는 **접근 제어(Access Control)** 메커니즘도 함께 제공된다.
- 캡슐화와 접근제어는 객체를 두 부분으로 나눈다.
- 하나는 외부에서 접근 가능한 부분으로 이를 **퍼블릭 인터페이**스 라고 부른다.
- 다른 하나는 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 **구현** 이라고 부른다.
- 인터페이스와 구현의 분리 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야하는 핵심 원칙이다.

### 협력하는 객체들의 공동체
- 시스템에 어떤 기능을 구현하기 위해 겍체들 사이에 이뤄지는 상호작용을 **협력(Collaboration)** 이라고 한다.

### 협력에 관한 짧은 이야기
- 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 **요청(request)** 할 수 있다.
- 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 **응답(response** 할 수 있다.
- 객체가 다른 객체와 상호작율 할 수 있는 유일한 방법은 **메세지를 전송** 하는 것 뿐이다.
- 다른 객체에 요청이 도착할 때 해당 객체가 **메세지를 수신** 했다고 이야기한다.
- 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다.
- 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드(Method)** 라고 한다.

#### 템플릿 패턴
- 부모 클래스 (스위프트에서는 protocol default implementation?)에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인패턴

#### 오버라이딩 vs 오버로딩
- 오버라이딩 : 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우를 말함
- 오버로딩은 : 메서드의 이름은 같지만 제공되는 파라미터 목록이 다를때 사용

### 상속과 다형성

#### 컴파일 시간 의존성과 실행 시간 의존성
- 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.
- 유연하고 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 의존성과 싱행 시간의 의존성이 다르다는 것
- 하지만 두 의존성이 다를 수록 코드를 이해하기 어려워진다.

#### 차이에 의한 프로그래밍
- 상속은 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있는 간편한 방법을 제공
- 상속을 이용하면 부모 클래스의 구현은 공유하면서도 행동이 다른 자식 클래스를 쉽게 추가할 수 있음
- 이처럼 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 `차이에 의한 프로그래밍(Programming by difference)` 라고 부른다.

#### 상속과 인터페이스
- 상속이 가치 있는 이슈는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.

#### 다형성
- 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행되는 것일지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라지는데, 이를 `다형성`이라고 부른다.
- 다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.
- 다시 말해 메시지와 메서드를 실행 시점에 바인딩한다는 것이다.
- 이를 `지연 바인딩(Lazy binding)`, `동적 바인딩(dynamic binding)` 이라고 부른다. 
- 이에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 `초기 바인딩(early binding)`, `정적 바인딩(static binding)` 이라고 부른다.

#### 인터페이스와 다형성
- 상속과 달리 구현은 공유할 필요가 없고 순수하게 인터페이스만 공유하고 싶을 때가 있다. 이때 `인터페이스` or `Protocol`을 이용할 수 있다.
- 말 그래도 구현에 대한 고려 없이 다형적인 협력에 참여하는 클래스들이 공유 가능한 외부 인터페이스를 정의하는 것이다.

### 추상화와 유연성
- 추상화를 사용하면 세부적인 내용은 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
- 이런 특징은 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 새념을 설명할 수 있게 한다.
- 재사용 가능한 설계의 기본을 다루는 `디자인 패턴`, `프레임워크` 모두 추상화를 이용해 상위 정책응 정의하는 객체지향 메커니즘을 활용하고 있다.

#### 코드 재사용
- 상속 보다는 `합성(composition)`을 사용하자.
- 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함하여 재사용하는 방법을 말한다.

#### 상속의 문제점
- 가장 큰 문제점은 캡슐화를 위반한다는 것이다.
- 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.
- 이는 자식 과 부모를 강하게 결합되도록 만들고 부모를 변경할 때 자식도 함께 변경될 확률을 높힌다.
- 두번째 단점은 설계가 유연하지 않다는 것이다.
- 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정된다.
- 따라 실행 시점에 객체의 종류를 변경하는 것이 불가능하다. (이것은 테스트에도 영향이 있을듯)

# 역할, 책임, 협력
- 객체지향 패러다임의 관점에서 핵심은 `역할(Role)`, `책임(Responsibility)`, `협력(Collaboration)` 이다.

## 협력
- 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 `협력`이라고 한다.
- 객체가 협력에 참여하기 위해 수행하는 로직을 `책임` 이라고 한다.
- 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 `역할`을 구성한다.

> 협력이란 어떤 객체가 다른 객체에게 무엇인가를 요청하는 것이다. 한 객체는 어떤 것이 필요할 때 다른 객체에게 전적으로 위임하거나 서로 협력한다. 즉, 두 객체가 상호작용을 통해 더 큰 책임을 수행하는 것이다. 객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야한다.

- 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상시킬 수 있다.
- 객체를 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화 하는 것이다.

## 책임
- 협력에 참여하기 위해 객체가 수행하는 행동을 `책임` 이라고 부른다.
- 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 유지해야하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.
- 즉, 객체의 책임은 객체가 무엇을 알고 있는지, 무엇을 할 수 있는지로 구성된다.

- `하는 것(doing)`
  - 객체를 생성하거나계산을 수행하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작시키는 것
  - 다른 객체의 활동을 제어하고 조절하는 것
- `아는 것(knowing)`
  - 사적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

- 객체 지향 설계에서 가장 중요한 것은 책임이다.
- 객체에게 얼마나 적절한 책음을 할당하느냐가 설계의 전체적인 품질을 결정한다.

### 책임 할당
- 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다.
- 이를 책임 할당을 위한 `Information Expert(정보 전문가)` 패턴 이라고 부른다.

### 책임 주도 설계
- 책임을 갖고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 `책임 주도 설계(Responsibility-Driven Design), RDD` 라고 부른다.
- 책임 주도 설계 방법의 과정
  - 시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.
  - 시스템 책임을 더 작은 책임으로 분할한다.
  - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
  - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
  - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

### 메시지가 객체를 결정한다.
- 객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택하는 것이 중요한다.
- 다시 말해 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 하는 것이다.
- 위의 방식은 2가지 중요한 이유가 있다.
  - 객체가 최소한의 인터페이스를 가질 수 있게 한다.
  - 객체가 충분히 추상적인 인터페이스를 가질 수 있게 한다.

### 행동이 상태를 결정한다.
- 객체가 협력에 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이다.
- 얼마나 적절한 객체를 창조했느냐는 얼마나 적절한 책임을 할당 했느냐에 달려있다.
- 책임이 얼마나 적절한지는 협력에 얼마나 적절한가에 달려있다.

## 역할

### 역할과 협력
- 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 **역할** 이라고 부른다.

### 유연하고 재사용 가능한 혁력
- 역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문인다.
- 책임과 역할을 중심으로 협력을 바라보는 것이 바로 변경과 확장이 용이한 유연한 설계로 나아가는 첫걸음이다.

### 객체 대 역할
- 역할음 객체가 참여할 수 있는 일종의 실록이다.
- 협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 되지만 단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체가 된다,
- 다시말해 현력에 적합한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주한다.
- 만약 여라 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 된다.
- 다양한 객체들이 협력에 참여하는 것이 확실하다면 역할로 시작하라.
- 하지만 모든 것이 안개로 속에 둘러 싸여 있고 정확한 결정을 내리기 어려운 상황이라면 구체적인 객체로 시작하라.
- 중요한 것은 협력을 구체적인 객체가 아니라 추살적인 역할의 관점에서 설계하면 협력이 유연하고 재사용 가능해진다는 것이다.
- 따라서 역할의 가장 큰 장점은 설계의 구성 요소를 추상화 할 수 있다는 것이다.

### 역할과 추상화
- 역할은 공통의 책임을 바탕으로 객체를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화로 볼 수 있다.
- 추상화가 가지는 장점은 협력의 관점에서 역할에도 동일하게 적용될 수 있다.
- 객체에게 중요한 것은 행동이라는 사실을 기억하자.
- 역할이 중요한 이유는 동일한 협력을 수행하는 객체들을 추상화 할 수 있기 때문이다.

### 설계 품질과 트레이드 오프
- 협력은 애플리케이션의 기능을 구현하기 위해 메세지를 주고 받는 객체들 사이의 상호작용이다.
- 책임은 객체가 다른 객체와 협력하기 위해 수행하는 행동이다.
- 역할은 대체 가능한 책임의 집합이다.
- 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.

## 설계 트레이드 오프

### 캡슐화
- 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장체를 제공하기 때문이다.
- 변경될 가능성이 높은 부분을 구현이라고 부르고 상대적으로 안정적인 부분을 인터페이스라고 부른다.
- 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다.
- 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 당순화하는 추상화의 한 종류다.

### 응집도와 결합도
- 응집도
  - 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.
  - 모듈 내의 요소들이 서로 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가진다.
  - 객체지향의 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.

- 결합도
  - 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.

- 높은 응집도, 낮은 결합도를 추구해야하는 이유는 설계를 변경하기 쉽게 만들기 때문이다.
- 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도를 측정할 수 있다.

### 단일 책임 원칙 (SRP. Single Responsibility Principle)
- 로버트 마틴은 모듈의 응집도가 변경과 연관이 있다는 사실을 강조하기 위해 단일 책임 원칙이라는 설계 원칙을 제시했다.
- 단일 책임 원칙을 한마디로 요약하면 클래스는 단 한가지의 변경 이유만 가져야한다는 것이다.
- 주의할 점은 단일 책임 원칙이라는 맥락에서 "책임"이라는 말이 변경의 이유 라는 의미로 사용된다는 점이다.

## 데이터 중심 설계의 문제점
- 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

### 객체의 행동보다는 상태에 초점을 맞춘다.
- 처음부터 데이터에 관해 결정하도록 강요하기 때문에 너무 이른 시기에 내부 구현에 초점을 맞추게 한다.
- 과도하게 사용되는 Getter, Setter는 public 속성과 큰 차이가 없기 때문에 객체의 캡슐화는 완전히 무너질 수 밖에 없다.
- 결론적으로 캡슐화에 실패하게 되고 객체의 내부 구현이 객체의 인터페이스를 어지럽히고 객체의 응집도와 결합도에 나쁜 영향을 미치기 때문에 변경에 취약한 코드를 낳게 된다.

# 책임 할당하기

## 책임 주도 설계를 향해
- 데이터 중식의 설계에서 책임 중심의 설계로 전환하기 위해서는 다음의 두 가지 원칙을 따라야 한다.
  - 데이터보다 행동을 먼저 결정하라
  - 협력이라는 문맥 안에서 책임을 결정하라

### 데이터보다 행동을 먼저 결정하라
- 책임 중심의 설계에서는 "이 객체가 수행해야하는 책임은 무엇인가"를 결정한 후에 "이 책임을 수행하는데 필요한 데이터는 무엇인가"를 결정한다.
- 객체지향 설계에서 가장 중요한 것은 적절한 객체에게 적절한 책임을 할당하는 능력이다.

### 협력이라는 문맥 안에서 책임을 결정하라
- 객체에게 할당된 책임의 품질은 협력에 적합한 의도로 결정된다.
- 객체에게 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 것이다.
- 협력을 시작하는 주체는 메시지 전송자이기 때문에 협력에 적합한 책임이란 메시지 수신자가 아니라 메시지 전송자에게 적잡한 책임을 의미한다.
- 즉 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 한다는 것이다.

정리해보면,
- 객체에게 적절한 책임을 한당하기 위해서는 협력이라는 문맥을 고려해야한다.
- 협력이라는 문맥에서 적절한 책임이란 곧 클라이언트의 관점에서 적절한 책임을 의미한다.
